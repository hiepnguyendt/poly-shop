{"version":3,"file":"direction.js","sourceRoot":"","sources":["../../../src/internal/direction.ts"],"names":[],"mappings":"AAAA,qEAAqE;AACrE,sCAAsC;AAEtC,MAAM,UAAU,QAAQ,CAAC,OAAwC;IAC/D,IAAI,CAAC,OAAO,EAAE;QACZ,OAAO,KAAK,CAAC;KACd;IACD,OAAO,gBAAgB,CAAC,OAAO,CAAC,CAAC,SAAS,KAAK,KAAK,CAAC;AACvD,CAAC;AAED,MAAM,UAAU,oBAAoB,CAAC,OAAoB;;IACvD,MAAM,iBAAiB,GAAG,MAAA,MAAA,OAAO,CAAC,YAAY,0CAAE,WAAW,mCAAI,CAAC,CAAC;IACjE,OAAO,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,iBAAiB,GAAG,OAAO,CAAC,WAAW,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC;AAC/G,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,oBAAoB,CAAC,OAAoB;IACvD,OAAO,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;AACjG,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,iBAAiB,CAAC,KAAmB,EAAE,KAAc;IACnE,OAAO,KAAK,CAAC,CAAC,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC;AACtF,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,4BAA4B,CAAC,OAAiC;IAC5E,MAAM,kBAAkB,GAAG,OAAO,CAAC,qBAAqB,EAAE,CAAC;IAE3D,MAAM,SAAS,GAAG,kBAAkB,CAAC,MAAM,CAAC;IAC5C,MAAM,UAAU,GAAG,kBAAkB,CAAC,KAAK,CAAC;IAC5C,MAAM,eAAe,GAAG,kBAAkB,CAAC,GAAG,CAAC;IAC/C,MAAM,aAAa,GAAG,kBAAkB,CAAC,MAAM,CAAC;IAChD,MAAM,gBAAgB,GAAG,QAAQ,CAAC,OAAO,CAAC;QACxC,CAAC,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,GAAG,kBAAkB,CAAC,KAAK;QACjE,CAAC,CAAC,kBAAkB,CAAC,IAAI,CAAC;IAC5B,MAAM,cAAc,GAAG,gBAAgB,GAAG,UAAU,CAAC;IAErD,OAAO;QACL,SAAS;QACT,UAAU;QACV,eAAe;QACf,aAAa;QACb,gBAAgB;QAChB,cAAc;KACf,CAAC;AACJ,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,eAAe,CAAC,KAAiB;IAC/C,OAAO,KAAK,CAAC,MAAM,YAAY,WAAW,IAAI,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC;QAClE,CAAC,CAAC,QAAQ,CAAC,eAAe,CAAC,WAAW,GAAG,KAAK,CAAC,KAAK;QACpD,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC;AAClB,CAAC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport function getIsRtl(element: null | HTMLElement | SVGElement): boolean {\n  if (!element) {\n    return false;\n  }\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nexport function getOffsetInlineStart(element: HTMLElement) {\n  const offsetParentWidth = element.offsetParent?.clientWidth ?? 0;\n  return getIsRtl(element) ? offsetParentWidth - element.offsetWidth - element.offsetLeft : element.offsetLeft;\n}\n\n/**\n * The scrollLeft value will be a negative number if the direction is RTL and\n * needs to be converted to a positive value for direction independent scroll\n * computations. Additionally, the scrollLeft value can be a decimal value on\n * systems using display scaling requiring the floor and ceiling calls.\n */\nexport function getScrollInlineStart(element: HTMLElement) {\n  return getIsRtl(element) ? Math.floor(element.scrollLeft) * -1 : Math.ceil(element.scrollLeft);\n}\n\n/**\n * The clientX position needs to be converted so it is relative to the right of\n * the document in order for computations to yield the same result in both\n * element directions.\n */\nexport function getLogicalClientX(event: PointerEvent, IsRtl: boolean) {\n  return IsRtl ? document.documentElement.clientWidth - event.clientX : event.clientX;\n}\n\n/**\n * The getBoundingClientRect() function returns values relative to the top left\n * corner of the document regardless of document direction. The left/right position\n * will be transformed to insetInlineStart based on element direction in order to\n * support direction agnostic position computation.\n */\nexport function getLogicalBoundingClientRect(element: HTMLElement | SVGElement) {\n  const boundingClientRect = element.getBoundingClientRect();\n\n  const blockSize = boundingClientRect.height;\n  const inlineSize = boundingClientRect.width;\n  const insetBlockStart = boundingClientRect.top;\n  const insetBlockEnd = boundingClientRect.bottom;\n  const insetInlineStart = getIsRtl(element)\n    ? document.documentElement.clientWidth - boundingClientRect.right\n    : boundingClientRect.left;\n  const insetInlineEnd = insetInlineStart + inlineSize;\n\n  return {\n    blockSize,\n    inlineSize,\n    insetBlockStart,\n    insetBlockEnd,\n    insetInlineStart,\n    insetInlineEnd,\n  };\n}\n\n/**\n * The pageX position needs to be converted so it is relative to the right of\n * the document in order for computations to yield the same result in both\n * element directions.\n */\nexport function getLogicalPageX(event: MouseEvent) {\n  return event.target instanceof HTMLElement && getIsRtl(event.target)\n    ? document.documentElement.clientWidth - event.pageX\n    : event.pageX;\n}\n"]}